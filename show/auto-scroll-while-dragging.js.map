{"version":3,"file":"auto-scroll-while-dragging.js","sources":["../src/helpers.ts","../src/index.ts"],"sourcesContent":["export function throttle<T extends unknown[], U>(\n  callback: (...args: T) => PromiseLike<U> | U,\n  /** Default is 0. */\n  wait = 0,\n) {\n  let canRun = true;\n  return function (this: unknown, ...args: T): Promise<U> | void {\n    if (!canRun) return;\n    canRun = false;\n    return new Promise((resolve) => {\n      window.setTimeout(() => {\n        canRun = true;\n        resolve(callback.call(this, ...args));\n      }, wait);\n    });\n  };\n}\n\n/**\n * Returns the passed element if scrollable, else the closest parent\n * that will, up to the entire document scrolling element\n */\nexport function getScrollElement(el: Node | null = null): HTMLElement {\n  if (!el) {\n    return (document.scrollingElement || document.documentElement) as HTMLElement;\n  }\n  return isElementOverflowScroll(el)\n    ? (el as HTMLElement)\n    : getScrollElement(el.parentElement);\n}\n\nexport function isElementOverflowScroll(el: Node) {\n  if (el instanceof HTMLElement) {\n    const style = getComputedStyle(el);\n    return /(auto|scroll)/.test(style.overflow + style.overflowY);\n  } else return false;\n}\n","import { getScrollElement, isElementOverflowScroll, throttle } from './helpers';\n\nlet scrollElRef: undefined | { scrollEl: HTMLElement; rect: DOMRect };\n\ninterface AutoScrollWhileDragging {\n  (options?: {\n    /** The root element which will listen the drag event. Default is `document.body`. */\n    rootEl?: HTMLElement;\n    /** The scroll speed, default is 0.3 */\n    speed?: number;\n    /** The max gap between mouse pointer and the bound of scroll element. Default is `100`, unit is `px`. */\n    gap?: number;\n    /** Define delay of throttle dragging. Default is `20`, unit is `ms`. */\n    throttleDelay?: number;\n  }): () => void;\n  dragStartHandler: (e: DragEvent) => void;\n  dragHandler: (e: DragEvent) => void;\n  dragEndHandler: () => void;\n}\n\n/**\n * Enhance the auto-scrolling behavior while dragging.\n * It returns a function which will clear effects.\n */\nexport const autoScrollWhileDragging = ((options = {}) => {\n  const { rootEl = document.body, speed = 0.3, gap = 100, throttleDelay = 20 } = options;\n\n  const dragStartHandler = (e: DragEvent) => {\n    if (!(e.target instanceof Node)) return;\n    const scrollEl = getScrollElement(e.target),\n      rect = scrollEl.getBoundingClientRect();\n    scrollElRef = { scrollEl, rect };\n  };\n  const dragHandler = throttle(\n    (e: DragEvent) => handleDrag(e, speed, gap),\n    throttleDelay,\n  );\n  const dragEndHandler = () => (scrollElRef = undefined);\n\n  // export the drag-related handlers for some specific cases to handle\n  // the drag event themself, eg: dragging in a virtual list with `react-dnd`\n  autoScrollWhileDragging.dragStartHandler = dragStartHandler;\n  autoScrollWhileDragging.dragHandler = dragHandler;\n  autoScrollWhileDragging.dragEndHandler = dragEndHandler;\n\n  rootEl.addEventListener('dragstart', dragStartHandler);\n  rootEl.addEventListener('drag', dragHandler);\n  rootEl.addEventListener('dragend', dragEndHandler);\n\n  return () => {\n    scrollElRef = undefined;\n    rootEl.removeEventListener('dragstart', dragStartHandler);\n    rootEl.removeEventListener('drag', dragHandler);\n    rootEl.removeEventListener('dragend', dragEndHandler);\n  };\n}) as AutoScrollWhileDragging;\n\n// Auto scroll while dragging\nfunction handleDrag(e: DragEvent, speed: number, gap: number) {\n  if (!scrollElRef) return;\n  const { scrollEl, rect } = scrollElRef;\n  const MAX_INNER_GAP = gap;\n  const step = (d: number) => Math.min(2 * MAX_INNER_GAP, MAX_INNER_GAP - d) * speed;\n\n  if (isElementOverflowScroll(scrollEl)) {\n    let top = rect.top + window.scrollY,\n      bottom = rect.bottom + window.scrollY;\n    if (e.clientY - top <= MAX_INNER_GAP) {\n      scrollEl.scrollTop -= step(e.clientY - top);\n    } else if (bottom - e.clientY <= MAX_INNER_GAP) {\n      scrollEl.scrollTop += step(bottom - e.clientY);\n    }\n  } else {\n    // if the scroll elementâ€˜s overflow is not `scroll` or `auto`, set `scrollTop`\n    // won't scroll the element, then we need use `window.scrollTo`\n    let top = rect.top + window.scrollY,\n      bottom = Math.min(rect.bottom - window.scrollY, window.innerHeight);\n    if (e.clientY - top <= MAX_INNER_GAP) {\n      window.scrollTo({ top: window.scrollY - step(e.clientY - top) });\n    } else if (bottom - e.clientY <= MAX_INNER_GAP) {\n      window.scrollTo({ top: window.scrollY + step(bottom - e.clientY) });\n    }\n  }\n}\n"],"names":[],"mappings":"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"}